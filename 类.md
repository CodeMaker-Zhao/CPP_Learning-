### 7.1 	抽象数据类型

定义在类内部的函数是隐式inline函数。

this是访问调用它的那个对象，this总是指向这个对象，所以this是一个常量指针，不允许改变this中保存的地址。默认情况下,this是指向类类型的非常量版本的常量指针，比如Sales_data *const，这样的话我们就不能把this绑定到一个常量对象上去，this是隐式的，并且不会出现在参数列表中，所以一般把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针，这样的成员函数被称为**常量成员函数**。

编译器处理类分两步：第一步编译成员的声明，第二部编译成员函数体。在类外部定义的成员名字必须包含它所属的类名。

IO类属于不能被拷贝的类型，所以使用它时我们一般都是进行引用传递。

### 7.2	构造函数

构造函数没有返回类型，不能被声明成const。如果不为类提供初始化构造函数的话，他们就会执行默认初始化，类通过**默认构造函数**来控制默认初始化的过程，编译器创造的构造函数被称为**合成的默认构造函数**，如果存在类的初始值，则用它来初始化成员，否则将进行默认初始化。

**只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数**。

如果类包含内置类型或复合类型的成员，只有他们都被赋予了类内的初始值，才不会造成未定义的情况。

```c++
struct Sales_data{
	Sales_data() = default;//定义这个构造函数的目的是因为需要其他形式的构造函数，也需要默认的构造函数，希望这个函数作用等同于之前的合成的默认构造函数。
  Sales_data(const string &s):bookNo(s){} 
}
```

### 7.3	访问控制与封装

当我们需要把一些成员与接口分离开，进行封装操作，用private限定成员只能被类内部访问到，struct和class的区别就在于，class在访问说明符（private  public）前的内容都是默认private的，而stuct的内容默认都是public的。如果我们希望一个不是类成员但是是类接口的函数能够访问类内部的数据，就应该使用友元声明，在类的最开始或最后以friend开头声明函数。