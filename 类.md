### 7.1 	抽象数据类型

定义在类内部的函数是隐式inline函数。

this是访问调用它的那个对象，this总是指向这个对象，所以this是一个常量指针，不允许改变this中保存的地址。默认情况下,this是指向类类型的非常量版本的常量指针，比如Sales_data *const，这样的话我们就不能把this绑定到一个常量对象上去，this是隐式的，并且不会出现在参数列表中，所以一般把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针，这样的成员函数被称为**常量成员函数**。

编译器处理类分两步：**第一步编译成员的声明，第二部编译成员函数体**。在类外部定义的成员名字必须包含它所属的类名。

IO类属于不能被拷贝的类型，所以使用它时我们一般都是进行引用传递。

### 7.2	构造函数

构造函数没有返回类型，不能被声明成const。如果不为类提供初始化构造函数的话，他们就会执行默认初始化，类通过**默认构造函数**来控制默认初始化的过程，编译器创造的构造函数被称为**合成的默认构造函数**，如果存在类的初始值，则用它来初始化成员，否则将进行默认初始化。

**只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数**。

如果类包含内置类型或复合类型的成员，只有他们都被赋予了类内的初始值，才不会造成未定义的情况。

```c++
struct Sales_data{
	Sales_data() = default;//定义这个构造函数的目的是因为需要其他形式的构造函数，也需要默认的构造函数，希望这个函数作用等同于之前的合成的默认构造函数。
  Sales_data(const string &s):bookNo(s){} 
}
```

### 7.3	访问控制与封装

当我们需要把一些成员与接口分离开，进行封装操作，用private限定成员只能被类内部访问到，struct和class的区别就在于，class在访问说明符（private  public）前的内容都是默认private的，而stuct的内容默认都是public的。如果我们希望一个不是类成员但是是类接口的函数能够访问类内部的数据，就应该使用友元声明，在类的最开始或最后以friend开头声明函数。

### 7.4	类的一些特性

类可以自定义某种类型在类中的别名

```c++
class Screen{
public:
	typedef double TYPE;
}
```

类型成员通常出现在类开始的地方。

可以在类内部声明函数时添加inline修饰其为内联函数，也可在类外部定义时添加inline，最好只在类外部定义的地方说明inline，因为在内部定义的函数默认inline。

**mutable**关键字能够让类的成员成为**可变数据成员**，可变数据成员永远不会是const，即使他是const对象的成员，一个const成员函数可以改变一个可变数据成员的值。

**类内初始值必须使用=的初始化形式，或者花括号括起来的直接初始化形式。**如果使用（）的话会解读为定义一个函数。

当类的返回类型为自身类型时，这时如果不加引用，返回的就是*this的对象的副本，这个对象的副本跟原来的对象不是同一个。

当类的声明和定义分开时，这种声明会被称为**前向声明**，引入了名字并且指明这是一种类，在声明之后到定义之前，都是不完全类型，此时可以定义指向这种类型的指针或引用，也可以声明以不完全类型作为参数或返回类型的函数。

当一个类定义另外一个类为友元时，另外一个类可以访问前者中的所有成员。

### 7.5	类的作用域

一旦遇到了类名，**定义的剩余部分就在类的作用域中了，这里的剩余部分包括参数列表和函数体。**

```c++
void Window_mgr::clear(ScreenIndex i){
	Screen &s = sreen[i]
}//这个例子中，在函数名字前已经出现了类名，此时ScreenIndex已经算是在类的作用域中了，所以无需Window_mgr::ScreenIndex.
```

### 7.6	名字查找

对于一般的名字查找来说都是在自己所在的块中进行查找，在自己使用之前的声明，然后再往外找。对于类来说，如果一个名字代表了一种类型，则类不能再之后重新定义该名字。

```c++
typedef double Type;
class ac{
public:
	Type balance();
private:
	typedef double Type;//不应该重新定义
};
```

**成员初始化顺序和定义中出现的顺序一致。**

### 7.7	委托构造函数

```c++
class Sales_data{
public:
	Sales_data(std::string s,unsigned cnt,double price):
		bookNo(s),units_sold(cnt),revenue(cnt*price){}
	Sales_data():Sales_data("",0,0)
	Sales_data(std::string s):Sales_data(s,0,0){}
	Sales_data(std::istream &s):Sales_data(){read(s,*this)}
}
```

### 7.8	隐式的类类型转换

可以合法的通过单参数构造函数的参数隐式转化为我们需要的类

```c++
string null_back = "99999";
item.combine(null_back);
item.combine("9999");//错误，不能转换两次，只允许一步类类型转换
item.combine(string("9999"));//正确
item.combine(Sales_data("99999"));//正确
```

当使用**explicit**时会抑制单实参的构造函数，阻止隐式转换。

使用explicit之后，就只能进行直接初始化，不能拷贝初始化了。

```c++
Sales_data &combine(Sales_data&);//这是对于combine函数的定义
i.combine(s);//此时s是一个string对象
```

这是错误的，因为我们把s放入之后，生成的一个临时的Sales_data对象，并不是一个实际存在于内存中的对象，那么就无法使用引用了。如果是const Sales_data &就可以了，因为编译器可以自动为它创造一个Sales_data类型的对象。

### 7.9	聚合类

Public所有成员、没有定义任何构造函数、没有类内初始值、没有基类也没有virtual函数。用花括号进行初始化。

### 7.10	类的静态成员

在成员的声明之前加上关键字static使得其与类关联在一起，**静态成员函数不能声明成const,不包含this指针。**静态成员类似于全局变量，**静态数据成员定义在任何函数之外。**静态成员可以被提供const整数类型的类内初始值，不过要求静态成员必须是**constexpr**，初始值必须是常量表达式。**如果在类内部提供了一个初始值，成员的定义不能再制定一个初始值了。**

静态成员可以被用做默认实参。

静态成语的成员类型可以就是它所属的类类型，非静态类型只能声明成它所属类的指针或引用。