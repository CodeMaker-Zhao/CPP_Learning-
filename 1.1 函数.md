### 1.1	函数

操作系统通过调用main函数来执行程序，int指定函数的**返回类型**，main为**函数名**，main后的括号内为形参列表，花括号内的内容为**函数体**，这是函数的四个组成部分。

```c++
int main(){
  return 0;
}
```

### 1.2	编译程序

除了通过IDE直接进行程序编写外，还可以通过在命令行窗口进行编译，使用vs编译器的命令是cl。但是在一些情况下，于命令行窗口进行调用cl命令，命令行不会正常执行，解决方法参考

### 1.3	输入输出语句

```c++
#include <iostream>
int main(){
  int v1 = 0, v2 = 0;
  std::cin>>v1>>v2;
	std::cout<<"Hello World"<<std::endl;
}
```

Std::endl的作用是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。

### 1.4	读取数量不定的输入数据

```c++
#include <iostream>
int main(){
	int sum = 0, v = 0;
  while(std::cin>>v){
    sum+=v;
  }
}
```

此函数能够读取数量不定的输入数据，除非遇到文件结束符（windows中ctrl+z），或遇到一个无效输入时（例如读取到的不是整数）。

### 2.1	基本内置类型

基本数据类型包括**算术类型**和 **空类型（void）**。算术类型包括整型（int ,long,bool,char）和浮点型。

### 2.2	字面值常量

整型字面值可以用十进制、八进制、十六进制表示。八进制以0开头，十六进制以0x开头。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能带符号也可能无符号。浮点型默认是double。

### 2.3	变量

变量是一个具名的、可供程序操作的存储空间。C++中每个变量都有其数据类型，数据类型决定着比纳凉所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

用花括号进行初始化变量的形式被称为**列表初始化**，如果使用列表初始化存在数据丢失风险时，编译会报错。

定义在函数体内部的内置类型变量将**不被初始化**，它的值就是未定义的。

```c++
extern int i;//声明而不定义
int j;//声明并定义
extern int p = 3;//声明并定义
```

变量只能被定义一次，但是可以被声明很多次。声明能够使名字为程序知道，定义负责创建与名字关联的实体。

### 2.4	复合类型

复合类型指基于其他类型定义的类型。目前学到的有指针和引用。

```c++
int val = 3;
int &r1 = val;
```

r1一个引用，程序把引用和它的初始值绑定在一起，一旦完成初始化，引用会和它的初始值对象一直在一起，**不能重新绑定**  **，因此引用必须初始化。**引用不是一个对象，只是为已经存在的对象所起的另外一个名字。引用的类型和与之绑定的类型需要严格一致，除了两种情况以外。其中一种是const类型的引用，此时引用绑定的对象可以是能够经过类型转换成为引用类型的值。



指针与引用的区别在于，指针本身就是一个对象，并且指针无须在定义时赋初值。

```c++
int v1 = 100;
int *p1 = &v1;//此处&为取地址符
std::cout<<*p1<<std::endl;//此处*为解引用符，可以得出所指的对象。
```

空指针的声明方法

```c++
int *p1 = 0;
int *p2 = nullptr;
int *p3 = NULL;
```

特殊的指针**void\*指针**，对于void*指针存放的地址，指向什么类型的对象我们是不知道的。在指针中，也要求指针的类型与所指的对象类型严格相同，除了两种情况，其中一种是指向const类型的指针，这种指针可以接受非const类型对象。

### 2.5	const限定符

const能够限制变量不能执行改变其内容的操作。

默认状态下，const对象仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。对想要在多个文件中共享的const变量来说，解决办法是const变量声明还是定义都添加extern关键字。

const的引用

```c++
const int ci = 1024;
const int &r1 = ci;//正确，类型相同
int &r2 = ci;//错误，int类型引用不能绑定const int类型变量
int i = 1;
const int &r3 = i;//正确，初始化常量引用时，初始值可以是非常量的对象、表达式、字面值
const int &r4  = 42;
const int &r5 = r3*2;
```

在这个过程中，主要发生了以下两步：

```c++
	double dval = 3.14;
	const int &r = dval;
	
	const int temp = dval;
	const int &r = temp;
```

**指向常量的指针**没有要求指向的值一定是常量，只是不能通过指针改变指向的值。

```c++
const int i = 3;
const int *p = &i;
int pi = 4;
p = pi;//正确，但是不能通过p来改变pi的值
```

将*放在const前证明指针本身是一个常量，不能更改储存的对象地址,这种指针叫做**常量指针**。

```c++
int i = 0;
int *const p = &i;
```

顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量。顶层const更大意义上可以表示对象是常量，底层cosnt与指针和引用等复合类型的基本类型部分有关。

执行对象的拷贝操作时，顶层const不受影响，底层const的必须相同，或者两者可以转换，**非常量可以转换为常量，反之不行。**

```c++
int i = 0;
int *const p1 = &i;//顶层
const int ci = 42;//顶层
const int *p2 = &ci;//底层
const int *const p3 = p2;//顶层、底层
const int &r = ci;//底层

i = ci;//正确，顶层const不影响
p2 = p3;//p3顶层，且两者底层类型相同

int *p = p3;//错误，p3底层有const
p2 = p3;//正确，原因见上
p2 = &i;//正确，int可以转化为const int
int &r = ci;//错误
const int &r2 = i;//正确
```

