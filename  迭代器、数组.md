### 3.5	迭代器介绍

所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。

有迭代器的类型都有begin和end方法。begin返回指向第一个元素的迭代器，end返回指向容器“尾元素的下一位置”的迭代器，该迭代器指示的是容器一个本不存在的**“尾后”元素**，不能对其进行**解引用**操作。

```c++
*iter;//对iter解引用
iter->men;//等同于(*iter).men(),注意一定要有括号，点运算符优先于*
```

任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。

可以令一个迭代器与一个整数值相加减，返回值是向前或向后移动了若干个未知的迭代器。

Iter1-iter2获得的是一个**difference_type**的带符号的整型数。

### 3.6	数组

数组与vector有些不同，数组的大小是不能改变的，不像vector一样灵活，但性能较好。

默认情况下，数组的元素被**默认初始化**，取决于元素的类型，和定义的位置。内置类型的变量未被显式定义时，它的值由定义的位置决定，定义于任何函数体之外的变量被初始化为0，**在函数体内部的内置类型变量不被初始化**。

字符数组具有特殊性，可以用字符串字面值进行初始化，但是字符串字面值**结尾处有一个空字符**。对于字符数组，还有一条特殊的规则，如果把一个指向字符数组元素的指针放入cout<<后，**cout会默认将指针自动往下个元素指，读取下个元素并且一个字节一个字节的利用ASCII码转化为字符，一直输出到遇到结尾的空字符。**

```c++
char c[] = "hello"//一个大小为6的数组，包括空字符
```

数组不允许拷贝和赋值。

```c++
int *ptrs[10];//含有10个整型指针的数组。
int &refs[10];//错误，数组的元素应该为对象，引用不是对象
int(*parrray)[10] = &arr;//指向10个整数数组的指针
int(&arrRef)[10] =arr;//arrRef为一个10整数数组的引用
```

**在很多数组名字出现的地方，都默认为指向数组首元素的指针**

```c++
string nums[]{"one","two","three"};
string *p = nums；
```

此处p作为指针就是指向nums[0]。当使用auto时，上述原则成立，使用decltype时不成立。

```c++
auto p(nums);//p是一个指针
decltype(nums) as;//as是一个数组
```

指向数组元素的指针作用与迭代器类似，迭代器支持的运算它都支持。数组不是类类型，没有begin和end成员,但是可以将数组放入函数参数列表中得到指向第一个元素的指针和指向尾后元素的指针。

```c++
int ia[]{1,2,3,4,5,6,7,8};
int last = *(ia+4);
```

此时ia默认为指向数组首位的一个指针，对这个指针进行+4操作，就是将指针向后移动四位，然后在进行解引用，得到的应该是last=5;如果没有括号的话，如

```c++
int last = *ia+4
```

*操作符优先级高于+，会将ia[0]+4作为结果，last=5;

### 3.7	多维数组

```c++
int s[2][3] = {1,2,3,4,5,6}；
int s[2][3] = {{1,2,3},{4,5,6}};//两者相同
int s[2][3] = {1,2,3};//第一行显式初始化，第二行默认初始化
int s[2][3] ={{1},{4}};//第一行第一列和第二行第一列被显式初始化
```

利用范围for循环遍历多维数组时，一定要注意外层围度必须用&，内层如果需要改变循环变量值，也需要用&。

```c++
for(auto &row:s){
	for(auto &col:row){
		/*...*/
	}
}
```

因为当外层循环控制变量是数组的一个元素，它自身就代表一个数组，那么在内层循环中，当需要遍历它时，它的变量名会被编译器识别为指向数组首位的指针，是一个int*,指针是无法进行遍历的，所以会编译失败。

```c++
int ia[3][4];
for(auto p = begin(ia);p!=end(ia);++p){
	for(auto q = begin(*p);q!end(*p)++q){
}
}
```

此处是指针和多位数组的使用，外层p指针指向一个4个整数的数组，q初始化位指向p数组的第一位，q指向整数，就可以进行操作了。